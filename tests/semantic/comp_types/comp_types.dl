
//////////
// Test 1
//////////

// declare a component with an inner type
.comp A<Param> {
	.type inner = [ x : Param ]
	.decl rel ( a : inner )
	rel(["x"]).
}

// instantiate the component several times
.type type1 <: symbol
.type type2 <: symbol

.init x = A<type1>
.init y = A<type2>
.init z = A<type1>


// this should be fine
.decl relX( a : x.inner )
.decl relY( a : y.inner )
.decl relZ( a : z.inner )


// all relations should have different types
relX(x) :- relX(x).
relX(x) :- relY(x).
relX(x) :- relZ(x).

relY(x) :- relX(x).
relY(x) :- relY(x).
relY(x) :- relZ(x).

relZ(x) :- relX(x).
relZ(x) :- relY(x).
relZ(x) :- relZ(x).

//////////
// Test 2
//////////

.comp B<P> {
  .type T = branch {x:P}
  .decl R(x:T)
}
.init myB = B<number>
myB.R($branch(1)).
.printsize myB.R

//////////
// Test 3
//////////

.comp C<P> {
  .type P <: number
  .decl R(x:P)
}
.init myC = C<myType>
myC.R(1).
.printsize myC.R

//////////
// Test 4
//////////

.comp D<P> {
  .type X <: P
  .decl R(x:X)
}
.init myD = D<number>
myD.R(1).
.printsize myD.R

//////////
// Test 5
//////////

.type myT2 <: number
.comp E<P> {
  .type myT <: number
  .type X = P | myT
  .decl R(x:X)
}
.init myE = E<myT2>
myE.R(1).
.printsize myE.R

