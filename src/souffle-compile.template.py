
# --- JSON_DATA_TEXT variable is inserted before this line ---

## Exemple of JSON_DATA_TEXT
#JSON_DATA_TEXT = """{
#  "compiler": "/usr/bin/c++",
#  "compiler_id": "GNU",
#  "compiler_version": "8.3.0",
#  "msvc_version": "",
#  "includes": "-I/usr/include",
#  "std_flag": "-std=c++17",
#  "cxx_flags": " -fopenmp",
#  "cxx_link_flags": "",
#  "release_cxx_flags": "-O3 ",
#  "debug_cxx_flags": "-g",
#  "definitions": "-DRAM_DOMAIN_SIZE=64 -DUSE_NCURSES -DUSE_LIBZ -DUSE_SQLITE",
#  "compile_options": "",
#  "link_options": "-pthread -ldl -lstdc++fs /usr/lib/x86_64-linux-gnu/libsqlite3.so /usr/lib/x86_64-linux-gnu/libz.so /usr/lib/x86_64-linux-gnu/libncurses.so",
#  "rpaths": "/usr/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu",
#  "outname_fmt": "-o {}",
#  "libdir_fmt": "-L{}",
#  "libname_fmt": "-l{}",
#  "rpath_fmt": "-Wl,-rpath,{}",
#  "path_delimiter": ":",
#  "exe_extension": ""
#}"""

import argparse
import json
import os
import pathlib
import subprocess
import sys

conf = json.loads(JSON_DATA_TEXT)

parser = argparse.ArgumentParser(description="Compile c++ code generated by Souffle")
parser.add_argument('-l', action='append', default=[], metavar='LIBNAME', dest='lib_names', type=str, help="Basename of a functors library. eg: `-l functors` => libfunctors.dll")
parser.add_argument('-L', action='append', default=[], metavar='LIBDIR', dest='lib_dirs', type=lambda p: pathlib.Path(p).absolute(), help="Search directory for functors libraries")
parser.add_argument('-g', action='store_true', dest='debug', help="Debug build type")
parser.add_argument('-s', action='store_true', dest='swig', help="TODO")
parser.add_argument('-v', action='store_true', dest='verbose', help="Verbose")
parser.add_argument('source', metavar='SOURCE', type=lambda p: pathlib.Path(p).absolute(), help="C++ source file")

args = parser.parse_args()

if not os.path.isfile(args.source):
    raise RuntimeError("Cannot open source file: '{}'".format(args.source))

extname = args.source.suffix
if extname != ".cpp":
    raise RuntimeError("Source file is not a .cpp file: '{}'".format(args.source))

basename = args.source.stem
dirname = args.source.parent
exeext = conf['exe_extension']
exepath = pathlib.Path(dirname.joinpath("{}{}".format(basename, exeext)))

OUTNAME_FMT = conf['outname_fmt']
LIBDIR_FMT = conf['libdir_fmt']
LIBNAME_FMT = conf['libname_fmt']
RPATH_FMT = conf['rpath_fmt']
PATH_DELIMITER = conf['path_delimiter']
RPATHS = conf['rpaths'].split(PATH_DELIMITER)

cmd = []
cmd.append('"{}"'.format(conf['compiler']))
cmd.append(conf['definitions'])
cmd.append(conf['compile_options'])
cmd.append(conf['includes'])
cmd.append(conf['std_flag'])
cmd.append(conf['cxx_flags'])

if args.debug:
    cmd.append(conf['debug_cxx_flags'])
else:
    cmd.append(conf['release_cxx_flags'])

cmd.append(OUTNAME_FMT.format(exepath))
cmd.append(str(args.source))

cmd.append(conf['link_options'])
cmd.extend(list(map(lambda rpath: RPATH_FMT.format(rpath), RPATHS)))
cmd.extend(list(map(lambda libdir: LIBDIR_FMT.format(libdir), args.lib_dirs)))
cmd.extend(list(map(lambda libname: LIBNAME_FMT.format(libname), args.lib_names)))

cmd = " ".join(cmd)

if args.verbose:
    sys.stderr.write(cmd + "\n")

if exepath.exists():
    exepath.unlink()

status = subprocess.run(cmd, capture_output=True, text=True, shell=True)
if status.returncode != 0:
    sys.stdout.write(status.stdout)
    sys.stderr.write(status.stderr)

os.sys.exit(status.returncode)
